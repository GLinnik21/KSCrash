#!/usr/bin/env python
#
#  Copyright (c) 2025 Karl Stenerud. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall remain in place
# in this source code.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

### Reads a directory tree containing C/C++/ObjC source files and generates a
### namespacing header for all publicly accessible symbols


import clang.cindex
from pathlib import Path
import os
import re
import sys


def generate_header_contents(symbols):
    namespace_define = "KSCRASH_NAMESPACE"
    header_define    = "KSCRASH_NAMESPACE_H"
    namespace_macro  = "KSCRASH_NS"

    contents = f"""//
// Auto-generated file. DO NOT EDIT!
//
// Generated by namespacer.py
//
// This header conditionally applies namespaces to all exposed symbols so that multiple instances of
// this library can coexist in the same binary without causing duplicate symbol errors during linking.
// Each instance will appear to be accessed the same way, such as `someFunction()`, but the
// actual symbols in the binary will be `someFunction_mylib`, `someFunction_yourlib`, etc.
//
// To use this feature, define {namespace_define} as whatever you'd like appended to all public symbols.
// - Example: `{namespace_define}=_mylib` will append _mylib to all public symbols.
//
// When public symbols are changed/added/removed, this file must be regenerated.
// - To regenerate this file, run the Makefile command: `make namespace`
//

#ifndef {header_define}
#define {header_define}

#ifdef {namespace_define}

#define {namespace_macro}2(NAMESPACE, SYMBOL) SYMBOL##NAMESPACE
#define {namespace_macro}1(NAMESPACE, SYMBOL) {namespace_macro}2(NAMESPACE, SYMBOL)
#define {namespace_macro}(SYMBOL) {namespace_macro}1({namespace_define}, SYMBOL)

"""
    for symbol in symbols:
        line = f"#define {symbol} {namespace_macro}({symbol})"
        if len(line) > 120:
            line = f"#define {symbol} \\\n    {namespace_macro}({symbol})"
        contents += f"{line}\n"
    contents += f"""
#endif

#endif /* {header_define} */
"""
    return contents


def print_help():
    print(f"Usage: {sys.argv[0]} <sources-path> <dst-header-file>")


def print_all(src_dir):
    paths = get_compilation_unit_files(src_dir, [ # Paths matching these regexes are ignored
                                                    re.compile(".*KSCrashTestTools.*"),
                                                  ])
    for path in paths:
        tu = get_translation_unit(path)
        for cursor in tu.cursor.get_children():
            print(f"{cursor.kind}: {cursor.displayname}")


def matches_any(str, matchers):
    for matcher in matchers:
        if matcher.match(str):
            return True
    return False


def get_translation_unit(file_name):
    index = clang.cindex.Index.create()
    return index.parse(file_name)


def get_compilation_unit_files(path, ignore_matching):
    paths = []
    for p in Path(path).rglob("*"):
        if not p.is_file():
            continue
        if not p.suffix in [".h", ".hpp", ".c", ".cpp", ".m", ".mm"]:
            continue
        if matches_any(str(p), ignore_matching):
            continue;
        paths.append(p)
    return paths


def get_symbols_of_kind(translation_unit, kinds, ignore_matching):
    symbols = []
    for func_cursor in translation_unit.cursor.get_children():
        if not func_cursor.kind in kinds:
            continue
        if func_cursor.storage_class == clang.cindex.StorageClass.STATIC:
            continue
        func_name = re.sub(r"\(.*", "", func_cursor.displayname).strip()
        if len(func_name) == 0:
            continue
        if matches_any(func_name, ignore_matching):
            continue
        symbols.append(func_name)
    return list(dict.fromkeys(symbols))


def extract_swift_names(contents, ignore_matching):
    names = re.findall(r'NS_SWIFT_NAME\((.*)\)', contents)
    return [name for name in names if not matches_any(name, ignore_matching)]

def collect_symbols(path):
    tu = get_translation_unit(path)
    contents = Path(path).read_text()
    symbols = []
    symbols += extract_swift_names(contents, [
                                                re.compile(".*\\..*"),
                                                re.compile(".*\\).*"),
                                                re.compile("[^A-Z]"),
                                             ])
    symbols += get_symbols_of_kind(tu, [
                                        clang.cindex.CursorKind.FUNCTION_DECL
                                    ], [ # Symbols matching these regexes are ignored
                                        re.compile("^NS_.*"),
                                        re.compile("^CF_.*"),
                                        re.compile("^__CF.*"),
                                       ])
    symbols += get_symbols_of_kind(tu, [
                                        clang.cindex.CursorKind.VAR_DECL
                                    ], [ # Symbols matching these regexes are ignored
                                        re.compile("^BOOL$"),
                                        re.compile("^Boolean$"),
                                        re.compile("^CFBasicHashValue$"),
                                        re.compile("^CFIndex$"),
                                        re.compile("^FOUNDATION_EXPORT$"),
                                        re.compile("^KSCString$"),
                                        re.compile("^KSHTTPMultipartPostBody$"),
                                        re.compile("^KSReachabilityKSCrash$"),
                                        re.compile("^id$"),
                                        re.compile("^instancetype$"),
                                        re.compile("^llvm$"),
                                        re.compile("^namespace$"),
                                        re.compile("^nullable$"),
                                        re.compile("^swift$"),
                                        re.compile("^uintptr_t$"),
                                        re.compile("^objc_debug_.*"),
                                        re.compile("^NS.*"),
                                       ])
    symbols += get_symbols_of_kind(tu, [
                                        clang.cindex.CursorKind.OBJC_INTERFACE_DECL,
                                        clang.cindex.CursorKind.OBJC_CATEGORY_DECL,
                                        clang.cindex.CursorKind.OBJC_PROTOCOL_DECL,
                                        clang.cindex.CursorKind.OBJC_IMPLEMENTATION_DECL,
                                        clang.cindex.CursorKind.OBJC_CATEGORY_IMPL_DECL,
                                    ], [ # Symbols matching these regexes are ignored
                                       ])
    symbols += get_symbols_of_kind(tu, [
                                        clang.cindex.CursorKind.CLASS_DECL,
                                        clang.cindex.CursorKind.CLASS_TEMPLATE,
                                    ], [ # Symbols matching these regexes are ignored
                                       ])
    # Can't use this because the demangler has a namespace "swift", and blanket
    # replacing "swift" in this codebase will wreak havoc!
    # symbols += get_symbols_of_kind(tu, [
    #                                     clang.cindex.CursorKind.NAMESPACE,
    #                                 ], [ # Symbols matching these regexes are ignored
    #                                    ])
    symbols += [ # Manually add these because clang.cindex misses some things
                "llvm",
                "Demangle",
                "KSCrashMailProcess",
                "KSCrashAlertViewProcess",
                "KSCrashAppMemory",
                "KSCrashAppMemory",
                "KSCrashAlertViewProcess",
                "i_kslog_logObjCBasic",
                "i_kslog_logObjC",
                "KSCrashAppMemoryTrackerDelegate",
               ]
    symbols = list(dict.fromkeys(symbols))
    return symbols


def load_symbols_from_compilation_units(base_path):
    paths = get_compilation_unit_files(base_path, [ # Paths matching these regexes are ignored
                                                    re.compile(".*KSCrashTestTools.*"),
                                                  ])
    symbols = []
    for path in paths:
        symbols += collect_symbols(path)
    symbols = list(dict.fromkeys(symbols))
    symbols.sort()
    return symbols


def generate_header_file(src_dir, dst_file):
    # Clear before generating so that we don't load our own generated symbols.
    with open(dst_file, "w") as f:
        f.write("")

    symbols = load_symbols_from_compilation_units(src_dir)
    contents = generate_header_contents(symbols)

    with open(dst_file, "w") as f:
        f.write(contents)


if __name__ == "__main__":
    if len(sys.argv) != 3:
        print_help()
        sys.exit(1)

    src_dir = os.path.normpath(sys.argv[1])
    dst_file = os.path.normpath(sys.argv[2])

    # print_all(src_dir)
    generate_header_file(src_dir, dst_file)

    print(f"Header {dst_file} generated.")
